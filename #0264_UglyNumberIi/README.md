# [264. Ugly Number II](https://leetcode.com/problems/ugly-number-ii/)

## Description

<div class="content__u3I1 question-content__JfgR"><div><p>Write a program to find the <code>n</code>-th ugly number.</p>

<p>Ugly numbers are<strong> positive numbers</strong> whose prime factors only include <code>2, 3, 5</code>.&nbsp;</p>

<p><strong>Example:</strong></p>

<pre><strong>Input:</strong> n = 10
<strong>Output:</strong> 12
<strong>Explanation: </strong><code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> is the sequence of the first <code>10</code> ugly numbers.</pre>

<p><strong>Note: </strong>&nbsp;</p>

<ol>
	<li><code>1</code> is typically treated as an ugly number.</li>
	<li><code>n</code> <b>does not exceed 1690</b>.</li>
</ol></div></div>

## Solution
The key is to realize that each number is generated by a former number multiplied by 2, 3 or 5. In other word, we need 3 variables to record the indexs that point to one of the previous numbers. Just go through the following example for `n == 6`, you will know what I say clearly.
* Initial step i = 1
```c++
 ans = [1] // 1 is the first ugly number.
 index_2 = 0
 index_3 = 0
 index_5 = 0
```
* i = 2
```cpp
  ans[i] = min(2*ans[index_2],3*ans[index_3],5*ans[index_5])
  //we choose index_2, so update it.
  ++index_2
  ans = [1,2]
```
* i = 3
```cp
  ans[i] = min(2*ans[index_2],3*ans[index_3],5*ans[index_5])
  //we choose index_3, so update it.
  ++index_3
  ans = [1,2,3]
```
* i = 4
```cpp
  ans[i] = min(2*ans[index_2],3*ans[index_3],5*ans[index_5])
  //we choose index_2, so update it.
  ++index_2
  ans = [1,2,3,4]
```
* i = 5
```cpp
  ans[i] = min(2*ans[index_2],3*ans[index_3],5*ans[index_5])
  //we choose index_5, so update it.
  ++index_5
  ans = [1,2,3,4,5]
```
* i = 6
```cpp
  ans[i] = min(2*ans[index_2],3*ans[index_3],5*ans[index_5])
  //we choose index_2 and index_3, so update them.
  ++index_2
  ++index_3
  ans = [1,2,3,4,5,6]
```
Notice the situation in `i==6`. It may update more than one indexes.

_**Time complexity: O(n)**_
## Summary
It seems not that difficult. But I thought for a long time to figure out this method. May be I should take the direction of thinking carefully at first.
